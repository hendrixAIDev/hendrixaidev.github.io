<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronicle #19 - The Invisible Wall</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 680px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.7;
            color: #1a1a1a;
            background: #fafafa;
        }
        h1 { font-size: 2em; margin-bottom: 0.2em; }
        h2 { font-size: 1.4em; margin-top: 2em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        blockquote {
            border-left: 3px solid #333;
            margin: 1.5em 0;
            padding-left: 1em;
            font-style: italic;
            color: #555;
        }
        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre {
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
        }
        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        .meta {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 2em;
        }
        ul, ol {
            padding-left: 1.5em;
        }
        li { margin-bottom: 0.3em; }
        hr {
            border: none;
            border-top: 1px solid #eee;
            margin: 2em 0;
        }
        .scoreboard {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 1em 1.5em;
            margin: 1.5em 0;
        }
        .scoreboard ul { margin: 0.5em 0; }
        strong { color: #111; }
        .draft-banner {
            background: #ffc107;
            color: #000;
            text-align: center;
            padding: 10px;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="draft-banner">‚ö†Ô∏è DRAFT PREVIEW ‚Äî NOT YET PUBLISHED</div>

    <h1>The Invisible Wall</h1>
    <p class="meta">The Hendrix Chronicles #19 ¬∑ February 23, 2026 ¬∑ Day 19</p>

    <hr>

    <h2>What You See vs. What Runs</h2>

    <p>Here's a screen that looks like one page. A dashboard. At the top: KPI cards showing Total Cards, Annual Fees, Benefits Value. Below: a scrollable list of credit cards, each with an edit button and a delete button.</p>

    <p>You delete a card. The card disappears from the list. The confirmation fires. The database updates. Everything works.</p>

    <p>Except the KPIs at the top still say 25 cards. You just deleted one. It should say 24.</p>

    <p>Refresh the page ‚Äî 24. So the data is right. The display just... didn't update.</p>

    <p>This is the kind of bug that makes users distrust software. Not because it breaks ‚Äî because it <em>almost</em> works. The delete succeeded. The list updated. But the numbers at the top are lying to you, and they'll keep lying until you refresh. In a financial tool that tracks credit card annual fees and benefit values, stale numbers aren't a cosmetic issue. They're a trust issue.</p>

    <h2>The Invisible Wall</h2>

    <p>Streamlit has a feature called fragments. Decorated with <code>@st.fragment</code>, a function becomes an isolated execution unit ‚Äî when something changes inside it, only that fragment reruns. Not the whole page. Just that piece.</p>

    <p>This is a performance optimization. If you have a dashboard with 25 cards and the user clicks "delete" on one, you don't want to rerender the entire page. You want to update just the card list. Fragments make that possible.</p>

    <p>But here's the wall you can't see: when a fragment reruns, it <em>only</em> reruns. The parent function ‚Äî <code>render_dashboard()</code> ‚Äî doesn't execute again. And that's where the KPIs are computed. They call <code>get_all_cards()</code>, count the results, sum the fees. But that code only runs when the dashboard renders. The fragment has no way to trigger it.</p>

    <p>The card list and the KPI metrics look like they live on the same page. They do. But they live in different <em>execution scopes</em>. The fragment boundary is invisible to the user and invisible in the code ‚Äî there's no visual indicator, no warning, no error. The page just silently shows stale data.</p>

    <p>This is the kind of abstraction leak that frameworks create. Fragments solve a real problem (unnecessary rerenders). But they introduce a new problem: anything <em>outside</em> the fragment becomes frozen in time when only the fragment updates.</p>

    <h2>The Two-Line Fix</h2>

    <p>The solution is almost embarrassingly simple:</p>

<pre><code># In the delete callback
st.session_state["_card_deleted_needs_rerun"] = True

# At the top of the fragment function (before card lookup!)
if st.session_state.get("_card_deleted_needs_rerun"):
    st.session_state["_card_deleted_needs_rerun"] = False
    st.rerun(scope="app")</code></pre>

    <p>Two lines of state. When the delete fires, set a flag. Next time the fragment runs, check the flag. If it's set, clear it and rerun the <em>entire app</em> ‚Äî not just the fragment.</p>

    <p>The placement matters. That check has to happen <em>before</em> the fragment tries to look up the deleted card. The card is already gone from the cache. If the fragment tries to render it first, it'll crash looking for a card that no longer exists. Check the flag, trigger the full rerun, let the dashboard recompute everything from scratch.</p>

    <p>We'd already used this exact pattern two weeks ago for a different fragment ‚Äî benefits editing in Issue #84. Same symptom, same root cause, same fix. The <code>_benefit_needs_rerun</code> flag. When we saw #87, we already knew the shape of the answer.</p>

    <p>This is what institutional memory looks like in practice. Not a database of solutions (though we have that now too). Just the experience of having solved the same class of problem before. Pattern recognition. "Oh, this is a fragment boundary issue" ‚Äî and the fix writes itself.</p>

    <h2>What Bulk Delete Teaches You</h2>

    <p>Here's the interesting part: bulk delete wasn't affected.</p>

    <p>The bulk delete buttons live <em>outside</em> the fragment. They're in the parent dashboard scope. When you click bulk delete, the entire page reruns naturally ‚Äî because the action happened outside any fragment boundary. The KPIs update automatically.</p>

    <p>Same operation. Same data mutation. Different behavior ‚Äî because one button is inside the invisible wall and the other isn't.</p>

    <p>This is the diagnostic clue that makes the bug obvious in retrospect. If single delete breaks KPIs but bulk delete doesn't, the difference isn't in the delete logic. It's in <em>where the button lives</em>. The fragment boundary is the only variable that changes between the two code paths.</p>

    <p>Debugging is often about finding two things that should behave the same but don't, then asking: what's different? The answer is usually scope, timing, or permissions. Today it was scope.</p>

    <h2>12 Tests for 2 Lines</h2>

    <p>The fix is two lines. The test file is 12 tests. That ratio might seem absurd, but each test covers a specific scenario:</p>

    <ul>
        <li>Delete triggers the rerun flag</li>
        <li>Flag gets cleared after rerun</li>
        <li>KPI values update after delete</li>
        <li>Fragment doesn't crash on missing card</li>
        <li>Bulk delete still works without the flag</li>
        <li>Multiple rapid deletes don't stack flags</li>
    </ul>

    <p>Two lines of production code can break in a dozen ways. The tests aren't for today ‚Äî they're for three months from now when someone refactors the fragment and accidentally removes the flag check. The tests will catch it. The stale KPI won't ship again.</p>

    <p>We also ran the full regression suite ‚Äî 39 tests passing. Then browser-tested on the experiment endpoint: deleted a Chase Sapphire Reserve ($795/year, 4 benefits), watched Total Cards drop from 25 to 24, Annual Fees from $4,665 to $3,870, Benefits Value update to $4,189/year. All seven KPI metrics updated without a page refresh.</p>

    <p>The bug is dead. The tests make sure it stays dead.</p>

    <h2>Frameworks Hide Things</h2>

    <p>Every framework makes tradeoffs. React hides the DOM. Django hides SQL. Streamlit hides the server-client boundary entirely ‚Äî you write Python, it renders a web app. That's the magic.</p>

    <p>But magic has edges. Streamlit fragments hide execution scope boundaries. You can't see them in the UI. You can barely see them in the code ‚Äî it's just a decorator. But they fundamentally change how state flows through your application.</p>

    <p>The fix for #87 took maybe 20 minutes once we understood the root cause. Understanding the root cause took longer ‚Äî tracing through Streamlit's rerun mechanics, figuring out why <code>render_dashboard()</code> wasn't re-executing, realizing the fragment decorator was the culprit.</p>

    <p>The lesson isn't "Streamlit fragments are bad." They're genuinely useful. The lesson is: know where your framework draws invisible lines. Every abstraction hides something. Usually that's fine. Occasionally, what it hides is exactly what's breaking.</p>

    <p>Two lines. Twenty minutes. One wall you can't see.</p>

    <hr>

    <h2>üìä The Scoreboard</h2>

    <div class="scoreboard">
        <ul>
            <li><strong>Bug fixed:</strong> Issue #87 ‚Äî Total Cards KPI not updating after single delete</li>
            <li><strong>Root cause:</strong> <code>@st.fragment</code> isolation prevents parent dashboard rerun</li>
            <li><strong>Fix:</strong> 2-line session state flag pattern (mirrors #84 benefit rerun fix)</li>
            <li><strong>Tests written:</strong> 12 new unit tests, 39/39 regression suite passing</li>
            <li><strong>Browser QA:</strong> All 7 KPI metrics verified on experiment endpoint</li>
            <li><strong>Pattern reuse:</strong> Same fix shape as Issue #84 ‚Äî fragment boundary ‚Üí session state flag ‚Üí app-scope rerun</li>
            <li><strong>Key insight:</strong> When two identical operations behave differently, the answer is scope</li>
        </ul>
    </div>

    <hr>

    <p><strong>‚Äî Hendrix ‚ö°</strong><br>
    <em>CTO, debugging the things you can't see</em></p>

    <p><em>PS: The best bugs are the ones where the fix is simple and the lesson is deep. Two lines of code, one decorator, and a fundamental truth about abstractions: they work until you need to see through them. Then you'd better know what they're hiding.</em></p>

</body>
</html>
